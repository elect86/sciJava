/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package sciJava

import org.gradle.api.*
import org.w3c.dom.Node
import org.xml.sax.InputSource
import java.io.StringReader
import java.net.URL
import javax.xml.parsers.DocumentBuilderFactory


fun readPom(artifact: String, version: String): String {
    val domain = "https://maven.scijava.org/content/groups/public/org/scijava/"
    val spec = "$domain$artifact/$version/$artifact-$version.pom"
    return URL(spec).readText()
}

object Pom {
    var artifact = "pom-scijava"
    var version = "29.2.1"
}

class SciJavaPlugin : Plugin<Project> {

    override fun apply(project: Project) = parsePom(Pom.artifact, Pom.version)

    fun parsePom(artifact: String, version: String) {

        val dbFactory = DocumentBuilderFactory.newInstance()
        val dBuilder = dbFactory.newDocumentBuilder()
        val pom = readPom(artifact, version)
        val doc = dBuilder.parse(InputSource(StringReader(pom)))

        //optional, but recommended
        //read this - http://stackoverflow.com/questions/13786607/normalization-in-dom-parsing-with-java-how-does-it-work
        doc.documentElement.normalize()

        for (i in 0 until doc.documentElement.childNodes.length) {
            val child = doc.documentElement.childNodes.item(i)

            if (child.nodeName == "parent") {
                println("parent")
                var group: String? = null
                var art: String? = null
                var vers: String? = null

                for (j in 0 until child.childNodes.length) {
                    val parent = child.childNodes.item(j)

                    if (parent.nodeType == Node.ELEMENT_NODE)
                        when (parent.nodeName) {
                            "groupId" -> group = parent.textContent
                            "artifactId" -> art = parent.textContent
                            "version" -> vers = parent.textContent
                        }
                    if (group == "org.scijava" && art != null && vers != null)
                        parsePom(art, vers)
                }
            }

            if (child.nodeName == "properties")

                for (j in 0 until child.childNodes.length) {
                    val prop = child.childNodes.item(j)

                    if (prop.nodeType == Node.ELEMENT_NODE && prop.nodeName.endsWith(".version")) {

                        val dep = prop.nodeName.dropLast(8)
                        val content = prop.textContent
                        versions[dep] = when {
                            content.startsWith("\${") && content.endsWith(".version}") -> { // ${imagej1.version}
                                val resolve = content.drop(2).dropLast(9)
                                versions[resolve] ?: error("cannot resolve $resolve")
                            }
                            else -> content
                        }
                    }
                }
        }
    }
}

val versions = mutableMapOf<String, String>()